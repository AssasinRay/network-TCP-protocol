#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <string>
#include <iostream>
#include <sstream>
#include <vector>
#include <fstream> 
#include "window.h"

//using namespace std;
int		global_socket_UDP;   				//udp socket
struct addrinfo *p;

socklen_t theirAddrLen;
struct sockaddr  theirAddr;

// get sockaddr, IPv4 or IPv6:
void *get_in_addr(struct sockaddr *sa)
{
	return sa->sa_family == AF_INET
		? (void *) &(((struct sockaddr_in*)sa)->sin_addr)
		: (void *) &(((struct sockaddr_in6*)sa)->sin6_addr);
}
/***
set up the UDP port
***/
void set_up_socket(unsigned short int hostUDPport){
	struct addrinfo hints, *servinfo;
	int rv;
	memset(&hints, 0, sizeof hints);
	hints.ai_family = AF_UNSPEC;
	hints.ai_socktype = SOCK_DGRAM;
	hints.ai_flags = AI_PASSIVE; // use my IP
	char UDPport_str[17];
	sprintf(UDPport_str, "%d", hostUDPport);
	if ((rv = getaddrinfo(NULL, UDPport_str, &hints, &servinfo)) != 0) {
		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
		return ;
	}
	// loop through all the results and bind to the first we can
	for(p = servinfo; p != NULL; p = p->ai_next) {
		if ((global_socket_UDP = socket(p->ai_family, p->ai_socktype,
				p->ai_protocol)) == -1) {
			perror("receiver: socket");
			continue;
		}
		if (bind(global_socket_UDP, p->ai_addr, p->ai_addrlen) == -1){
			close(global_socket_UDP);
			perror("receiver: bind");
			continue;
		}
		break;
	}
	if (p == NULL)  {
		fprintf(stderr, "receiver: failed to bind\n");
		return ;
	}
	freeaddrinfo(servinfo); // all done with this structure
	std::cout<<"receiver: waiting for UDP connection ...."<<std::endl;
	return;
}

void send_packet(char* buffer, int len){
	int numBytes;
	numBytes = sendto(global_socket_UDP,buffer,len,0,(struct sockaddr *)&theirAddr,theirAddrLen);
	if(numBytes==-1){
		perror("acker: send failed");
		exit(1);
	}
	return ;
}


void reliablyReceive(unsigned short int myUDPport, char* destinationFile) {
	set_up_socket(myUDPport);

	std::vector<packet> output_buffer(10000000,NULL);
	window recv_window(10, myUDPport, "hostname",0);

	//things for receiving acks
	int bytesRecvd;
	unsigned long long int totalbytes=0;
	char recvBuf[50000];
	memset(recvBuf, '\0', 50000);
	unsigned long long int seq_end= 0;
	bool send_finished=false;

	while(1){

		//receive data
		theirAddrLen = sizeof(theirAddr);
		if ((bytesRecvd = recvfrom(global_socket_UDP, recvBuf, 50000, 0, 
			(struct sockaddr*)&theirAddr, &theirAddrLen)) == -1){
			perror("receiver receiving data failed");
			exit(1);
		}
		totalbytes+=bytesRecvd;

		//record received seqnum
		std::vector<unsigned long long int> received_packet_seq = recv_window.prepare_recv(recvBuf, bytesRecvd,output_buffer);
		//print ack num
		print_vector(received_packet_seq);

		//check finishied receive all the btytes
		if(received_packet_seq.back()==1844674407370955161){
			 send_finished=true;
		}
		if(send_finished==true) break;
		 seq_end = received_packet_seq.back();
		
		//send back ack seqnum
		recv_window.prepare_ack(received_packet_seq);
		send_packet(recv_window.payLoad_buffer,recv_window.total_packet_size);

	}

	std::cout<<"finish receiving file and total packets are "<<seq_end+1<<std::endl;
	output_buffer.resize(seq_end+1);
	write_file(output_buffer,destinationFile);
	close(global_socket_UDP);
}

int main(int argc, char** argv)
{
	unsigned short int udpPort;
	
	if(argc != 3)
	{
		fprintf(stderr, "usage: %s UDP_port filename_to_write\n\n", argv[0]);
		exit(1);
	}
	

	udpPort = (unsigned short int)atoi(argv[1]);
	std::cout<<"receive file in port "<<udpPort<<std::endl;

	reliablyReceive(udpPort, argv[2]);
}
